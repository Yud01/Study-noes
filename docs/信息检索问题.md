
# 倒排索引与信息检索优化方法

## 问题背景

当我们想要检索一本书中是否包含某个单词但**不包含**另外一个单词，最简单的做法是从头到尾扫描整本书。这种线性扫描方法被称为 **Grepping**（来自于 Linux 命令 `grep`，即全文搜索匹配）。

这种方法在处理文本量小的文档时是可行的，但在现实中处理大规模文本集合（如互联网文档）时完全不可行。

---

## 非线性优化方法：关联矩阵

为优化检索，我们可以建立一个**关联矩阵**，记录每个单词在哪些文档中出现：

- 每一行表示一个单词
- 每一列表示一个文档
- 值为 `1` 表示该词出现在该文档中，`0` 表示没有出现

例如：

```
词汇量：500,000  
文档数：1,000,000  
→ 总矩阵元素数：5000 亿
```

但由于每个文档只包含大约 1000 个单词，**超过 99.8% 的值都是 0**，也就是典型的**稀疏矩阵（Sparse Matrix）**，在机器学习中也难以直接利用。

---

## 信息检索中的两个核心指标

1. **准确率 Precision (P)**  
   \[
   P = \frac{\text{被检索到的相关文档数}}{\text{所有被检索到的文档数}}
   \]

2. **召回率 Recall (R)**  
   \[
   R = \frac{\text{被检索到的相关文档数}}{\text{所有相关文档数}}
   \]

---

## 倒排索引 Inverted Index

> “倒排”这个名字虽然来源不明，但已成为约定俗成的术语。

倒排索引记录以下两部分信息：

1. **词汇表（Vocabulary）**：文档中出现的所有单词集合  
2. **Postings List**：每个单词对应出现的文档编号列表

### 示例：

| Term      | Documents            |
|-----------|----------------------|
| Brutus    | Doc1, Doc2, Doc4     |
| Caesar    | Doc1, Doc2, Doc4, D5 |
| Calpurnia | Doc2                 |

查询 `Brutus AND Caesar AND NOT Calpurnia`：

- 先取交集：`Doc1, Doc2, Doc4` ∩ `Doc1, Doc2, Doc4, D5` → `Doc1, Doc2, Doc4`
- 再排除包含 Calpurnia 的 `Doc2` → 最终结果：**Doc1, Doc4**

---

## 倒排索引的构建过程

### Step 1：收集原始文档
```
Doc1: Friends, Romans, countrymen. So let it be with Caesar ...
```

### Step 2：分词（Tokenization）
```
Tokens: Friends Romans countrymen So let it be with Caesar
```

### Step 3：语言预处理
- 小写化 → `friends`  
- 词干提取（stemming） → `friend`  
- 去标点化  
- 最终标准化 Tokens：
```
friend roman countryman so let it be with caesar
```

### Step 4：构建倒排索引

如下图所示：

![倒排索引示意图](picture/screenshot_2025-09-08_15-25-35.png)

---

> ✅ 若你将此 `.md` 文件用于 MkDocs、Typora、VSCode、PyCharm 等工具，请确保 `picture/` 文件夹中已经包含上述图片，文件名、路径与 Markdown 中一致。